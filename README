Chat app using Sockets [ For linux ]

Socket Programming
* A way to speak to other programs using standard Unix file descriptor.
* "Jeez, everything in a Unix is a file."
* You make call to socket() routine and it returns socket decriptor which we use to communicate using send() and recv(), we could use write() and read() since its a file descriptor but send() and recv() provides much greater control over data transmissions.
*Mainly two types of sockets - Stream Sockets(SOCK_STREAM) and Datagram Sockets(SOCK_DGRAM, connectionless socket).
* Stream sockets are reliable two way communication sockets and has high level of data transmission quality, used in telnet apps, browsers use HTTP which uses stream sockets to get pages. They use TCP (Transmission Control Protocol) that makes sure that data comes error free and sequentially. IP deals with internet routing and not responsible for data integrity.
* Datagram Sockets also called connectionless sockets are unreliable, data may come or not but if comes is error free. They also use IP for internet routing but not TCP instead use UDP (User Datagram Protocol). They are connectionless because you dont have to maintain open connection like in stream sockets. You just build a packet, apply IP header on it with destination inforamtion and send it out. They are used when a TCP stack is unavailable or few dropped packates are acceptable so used in multiplayer games, audio video conferencing, DHCP client etc.
So why use such unreliable thing, just for speed and speed.

Data Encapsulaion
* [ Ethernet [ IP [ UDP [ TFTP [ DATA ] ] ] ] ]

Layered Network Model
• Application Layer (telnet, ftp, etc.)
• Host-to-Host Transport Layer (TCP, UDP)
• Internet Layer (IP and routing)
• Network Access Layer (Ethernet, wi-fi, or whatever)

IP Addresses
* IPv4
32 Bits
* IPv6
128 Bits
* 127.0.0.1 or ::1 is a loopback address is the address of current machine working on.

Subnets
* Logicial sub-division of IP network
* Netmask is a network portion of IP address which is bitwise-AND wih IP address to get network number. 
For an IP address of 192.0.2.12 we bitwise AND 255.255.255.0 to get 192.0.2.0 which is its network number. 

Port Number
* 16-bit number ranging from 0 to 65535 that's like the local address for connection. 
* Ports under 1024 are special purpose ports and requires special OS privileges to use.
* 21 FTP, 80 for HTTP, 22 for SSH etc... 

Byte Order
* Big-Endian ----  Network Byte Order ---- Big End First
* Little-Endian -- Host Byte Order ------- Used by computers to store numbers
* Conversion of Network Byte Order and Host Byte Order before they informations go out or in to host:
 htons() ---- host to network short
 htonl() ---- host to network long
 ntohs() ---- network to host short
 ntohl() ---- network to host long

*Program to Show IP address for a host
#include<iostream>
#include<cstring>
#include<sys/types.h>
#include<sys/socket.h>
#include<netdb.h>
#include<arpa/inet.h>
#include<netinet/in.h>

int main(int argc, char *argv[])
{
	struct addrinfo hints, *res, *p;
	int status;
	char ipstr[INET6_ADDRSTRLEN];
	if (argc != 2) 
	{
		fprintf(stderr,"usage: showip hostname\n");
		return 1;
	}
	memset(&hints, 0, sizeof hints);
	hints.ai_family = AF_UNSPEC; // AF_INET or AF_INET6 to force version
	hints.ai_socktype = SOCK_STREAM;
	if ((status = getaddrinfo(argv[1], NULL, &hints, &res)) != 0) 
	{
		fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(status));
		return 2;
	}
	printf("IP addresses for %s:\n\n", argv[1]);
	for(p = res;p != NULL; p = p->ai_next) 
	{
		void *addr;
		char *ipver;
		// get the pointer to the address itself,
		// different fields in IPv4 and IPv6:
		if (p->ai_family == AF_INET) 
		{ 
			// IPv4
			struct sockaddr_in *ipv4 = (struct sockaddr_in *)p->ai_addr;
			addr = &(ipv4->sin_addr);
			ipver = "IPv4";
		} 
		else
		{
			 // IPv6
			struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)p->ai_addr;
			addr = &(ipv6->sin6_addr);
			ipver = "IPv6";
		}
		// convert the IP to a string and print it:
		inet_ntop(p->ai_family, addr, ipstr, sizeof ipstr);
		printf(" %s: %s\n", ipver, ipstr);
	}
	freeaddrinfo(res); // free the linked list
	return 0;
}
	
Socket()
* socket() simply returns to you a socket descriptor that you can use in later system calls, or -1 on
error.

Bind()
* Associates the socket with a port on the computer, -1 on error.

connect()
* connect to a host using IP address and port number, -1 on error.

listen()
* listen for a connection

accept()
* Connects to a pending request and returns socket file descriptor to use for single connection, -1 on error.

send() and recv()
* used for communication over sockets, send returns number of bytes sent and recv() returns 0 if connection is lost, -1 on error as usual.

sendto() and recvfrom()
* used for SOCK_DATAGRAM to communicate with destination address.

close() and shutdown()
* close() closes the socket descriptor whereas shutdown() gives a little more control over how you close,0 on success and -1 on error. shutdown() doesnot close the descriptor but changes its usability, to free file descriptor we need to use close().

getpeername()
* tells you who is at the other end of SOCK_STREAM connection.

gethostname()
* return name of computer program is running on.



